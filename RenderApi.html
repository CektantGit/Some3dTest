<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vizbl FBX test</title>
    <style>
        body {
            overflow: hidden;
            margin: 0px;
        }

        a {
            color: #ffffff;
        }

        #instructions {
            color: white;
            position: absolute;
            left: 50%;
            top: 10px;
            margin-left: -120px;
            font-family: monospace;
        }

        #render-container {
            position: absolute;
            bottom: 0;
            left: 0;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .render-image {
            margin: 5px;
            border: 1px solid #ffffff;
        }

        .button-indicator .indicator {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 5px;
        }
    </style>
    <script src="https://unpkg.com/es-module-shims@1.5.0/dist/es-module-shims.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/OrbitControls.js",
                "FBXLoader": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/FBXLoader.js",
                "Stats": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/libs/stats.module.js",
                "RGBELoader": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/RGBELoader.js",
                "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="instructions">
        Importer for <a href="https://www.vizbl.us" target="_blank" rel="nofollow noopener">Vizbl</a>
    </div>
    <div id="render-container"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { FBXLoader } from 'FBXLoader';
        import Stats from 'Stats';
        import { RGBELoader } from 'RGBELoader';
        import * as dat from 'dat.gui';

        const scene = new THREE.Scene();

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const rgbeLoader = new RGBELoader();
        rgbeLoader.load("https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr", (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = new THREE.Color(0xffffff);
            scene.environment = texture;
            render();
        });

        const light = new THREE.PointLight(0xffffff, 0.1);
        light.position.set(0.8, 1.4, 1.0);
        scene.add(light);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const camera2 = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        camera.position.set(2.0, 1.0, 2.0);
        camera.lookAt(0, 0, 0);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        const renderContainer = document.querySelector("#render-container");

        const gui = new dat.GUI();
        const params = {
            loadFromAPI: loadModelAndTexturesFromAPI
        };

        gui.add(params, 'loadFromAPI').name('Load from API').domElement.classList.add('button-indicator');

        const modelMap = {};

        async function loadModelAndTexturesFromAPI() {
            try {
                const response = await fetch('https://api.vizbl.us/obj/Fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ tinuuid: 'oWb5XjXrRrOXazkxqveazg' })
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch data');
                }

                const data = await response.json();
                const materials = data.materials;
                const models = data.models;

                await loadModels(models);

                materials.forEach((materialGroup) => {
                    gui.add({ applyMaterials: () => applyMaterials(materialGroup) }, 'applyMaterials').name(materialGroup.name);
                });

            } catch (error) {
                console.error('Error loading model and textures:', error);
            }
        }

        async function loadModels(models) {
            for (const model of models) {
                const loadedModel = await loadFBXModel(model.url);
                modelMap[model.slug] = loadedModel;
            }
        }

        async function createMaterial(materialData) {
            const material = new THREE.MeshStandardMaterial();

            if (materialData.texture) {
                const textureUrl = getTextureUrl(materialData.texture);
                if (textureUrl) {
                    const texture = await loadTexture(textureUrl);
                    texture.colorSpace = THREE.SRGBColorSpace;
                    material.map = texture;
                }
            }

            if (materialData.normalMap) {
                const normalMapUrl = getTextureUrl(materialData.normalMap);
                if (normalMapUrl) {
                    material.normalMap = await loadTexture(normalMapUrl);
                }
            }

            if (materialData.textureMro) {
                const textureMroUrl = getTextureUrl(materialData.textureMro);
                if (textureMroUrl) {
                    const ormTexture = await loadTexture(textureMroUrl);
                    material.aoMap = ormTexture;
                    material.roughnessMap = ormTexture;
                    material.metalnessMap = ormTexture;
                    material.metalness = 1.0;
                }
            }

            material.needsUpdate = true;
            return material;
        }

        function getTextureUrl(textureData) {
            return textureData.url || textureData.subRes['1024'] || textureData.subRes['512'] || textureData.subRes['optim'];
        }

        async function loadFBXModel(url) {
            return new Promise((resolve, reject) => {
                const loader = new FBXLoader();
                loader.load(url, (object) => {
                    object.scale.set(0.01, 0.01, 0.01);
                    var box = new THREE.Box3().setFromObject(object);
                    //var center = new THREE.Vector3();
                    //box.getCenter(center);
                    //object.position.sub(center);
                    scene.add(object);
                    resolve(object);
                }, undefined, reject);
            });
        }

        async function loadTexture(url) {
            return new Promise((resolve) => {
                const texture = new THREE.TextureLoader().load(url, () => {
                    resolve(texture);
                });
            });
        }

        function applyMaterials(materialGroup) {
            materialGroup.items.forEach(async (materialData) => {
                const material = await createMaterial(materialData);
                const model = modelMap[materialData.slug];
                if (model) {
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = material;
                        }
                    });
                } else {
                    console.warn(`No model found for slug ${materialData.slug}`);
                }
            });
        }

        function render() {
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        render();
    </script>
</body>
</html>
